// Generated by CoffeeScript 2.0.2
(function() {
  var CELL_SIZE, Jelly, JellyCell, Stage, Wall, i, k, level, levelPicker, levels, moveToCell, option, ref, stage,
    indexOf = [].indexOf;

  levels = [
    // Level 1
    ["xxxxxxxxxxxxxx",
    "x            x",
    "x            x",
    "x      r     x",
    "x      xx    x",
    "x  g     r b x",
    "xxbxxxg xxxxxx",
    "xxxxxxxxxxxxxx"],
    ["xxxxxxxxxxxxxx",
    "x            x",
    "x            x",
    "x            x",
    "x     g   g  x",
    "x   r r   r  x",
    "xxxxx x x xxxx",
    "xxxxxxxxxxxxxx"],
    ["xxxxxxxxxxxxxx",
    "x            x",
    "x            x",
    "x   bg  x g  x",
    "xxx xxxrxxx  x",
    "x      b     x",
    "xxx xxxrxxxxxx",
    "xxxxxxxxxxxxxx"],
    ["xxxxxxxxxxxxxx",
    "x            x",
    "x       r    x",
    "x       b    x",
    "x       x    x",
    "x b r        x",
    "x b r      b x",
    "xxx x      xxx",
    "xxxxx xxxxxxxx",
    "xxxxxxxxxxxxxx"],
    // Level 5
    ["xxxxxxxxxxxxxx",
    "x            x",
    "x            x",
    "xrg  gg      x",
    "xxx xxxx xx  x",
    "xrg          x",
    "xxxxx  xx   xx",
    "xxxxxx xx  xxx",
    "xxxxxxxxxxxxxx"],
    ["xxxxxxxxxxxxxx",
    "xxxxxxx      x",
    "xxxxxxx g    x",
    "x       xx   x",
    "x r   b      x",
    "x x xxx x g  x",
    "x         x bx",
    "x       r xxxx",
    "x   xxxxxxxxxx",
    "xxxxxxxxxxxxxx"],
    [
      // Anchored jellies are specified separately after the
      // level map. Instead of [row, row, row...in the presence of
      // anchors the level specification is: 
      // [ [row,row,row...], [ anchor, anchor, anchor...] ].
      // Each anchor starts from a colored non-black jelly's
      // coordinates and specifies the direction in which it's "held".
      ["xxxxxxxxxxxxxx",
      "x            x",
      "x          r x",
      "x          x x",
      "x     b   b  x",
      "x     x  rr  x",
      "x         x  x",
      "x r  bx x x  x",
      "x x  xx x x  x",
      "xxxxxxxxxxxxxx"],
      [
        {
          x: 2,
          y: 7,
          dir: 'down'
        },
        {
          x: 5,
          y: 7,
          dir: 'down'
        }
      ]
    ],
    [
      ["xxxxxxxxxxxxxx",
      "xxxx x  x xxxx",
      "xxx  g  b  xxx",
      "xx   x  x   xx",
      "xx   b  g   xx",
      "xxg        bxx",
      "xxxg      bxxx",
      "xxxx      xxxx",
      "xxxxxxxxxxxxxx"],
      [
        {
          x: 5,
          y: 4,
          dir: 'up'
        },
        {
          x: 8,
          y: 4,
          dir: 'up'
        }
      ]
    ],
    [
      ["xxxxxxxxxxxxxx",
      "x            x",
      "x            x",
      "x          rbx",
      "x    x     xxx",
      "xb        00xx",
      "xx  rx  x xxxx",
      "xxxxxxxxxxxxxx"],
      [
        {
          x: 4,
          y: 6,
          dir: 'down'
        }
      ]
    ],
    [
      // Level 10
      ["xxxxxxxxxxxxxx",
      "x   gr       x",
      "x   00 1     x",
      "x    x x xxxxx",
      "x            x",
      "x  x  x      x",
      "x        x  rx",
      "xx   x     gxx",
      "x          xxx",
      "xxxxxxxxxxxxxx"],
      [
        {
          x: 11,
          y: 7,
          dir: 'down'
        },
        {
          x: 12,
          y: 6,
          dir: 'down'
        }
      ]
    ],
    [
      ["xxxxxxxxxxxxxx",
      "x      g00g gx",
      "x       xxx xx",
      "x           gx",
      "x11         xx",
      "xxx          x",
      "x       g    x",
      "x   x xxx   gx",
      "x   xxxxxx xxx",
      "xxxxxxxxxxxxxx"],
      [
        {
          x: 12,
          y: 7,
          dir: 'down'
        },
        {
          x: 7,
          y: 1,
          dir: 'right'
        },
        {
          x: 10,
          y: 1,
          dir: 'left'
        }
      ]
    ],
    [
      ["xxxxxxxxxxxxxx",
      "xxr rr  rr rxx",
      "xxx  x  x  xxx",
      "x            x",
      "xb          bx",
      "xx          xx",
      "x            x",
      "x            x",
      "x   xxxxxx   x",
      "xxxxxxxxxxxxxx"],
      [
        {
          x: 12,
          y: 4,
          dir: 'down'
        }
      ]
    ],
    ["xxxxxxxxxxxxxx",
    "xxxxxxxxxxxxxx",
    "xxxxx gr xxxxx",
    "xxxxx rb xxxxx",
    "xxxxx gr xxxxx",
    "xxxxx bg xxxxx",
    "xxxxxxxxxxxxxx",
    "xxxxxxxxxxxxxx"],
    [
      ["xxxxxxxxxxxxxx",
      "xxxxxxxxx   rx",
      "xxxxxxxxx   gx",
      "xxxxxxxxx   gx",
      "x1122       gx",
      "x1122       gx",
      "x0033      xxx",
      "x0033      xxx",
      "xxr x gxxx xxx",
      "xxxxxxxxxxxxxx"],
      [
        {
          x: 2,
          y: 8,
          dir: 'down'
        },
        {
          x: 6,
          y: 8,
          dir: 'down'
        }
      ]
    ],
    [
      // Level 15
      ["xxxxxxxxxxxxxx",
      "xr r r      rx",
      "xg x x      gx",
      "xb          bx",
      "xxxxx     xxxx",
      "xxxxxx   xxxxx",
      "xxxxxx   xxxxx",
      "xxxxxx   xxxxx",
      "xxxxxxgggxxxxx",
      "xxxxxxxxxxxxxx"],
      [
        {
          x: 1,
          y: 3,
          dir: 'down'
        },
        {
          x: 6,
          y: 8,
          dir: 'left'
        },
        {
          x: 8,
          y: 8,
          dir: 'right'
        }
      ]
    ],
    [
      ["xxxxxxxxxxxxxx",
      "xx   0001233rx",
      "xx   0411233xx",
      "xx   444122xxx",
      "xx     xxxxxxx",
      "xr     xxxxxxx",
      "xx     xxxxxxx",
      "xx     xxxxxxx",
      "xx     xxxxxxx",
      "xxxxxxxxxxxxxx"],
      [
        {
          x: 1,
          y: 5,
          dir: 'up'
        }
      ]
    ],
    [
      ["xxxxxxxxxxxxxx",
      "xxxx000xxxgb x",
      "xxxx0     bg x",
      "xxxx0    11xxx",
      "xxxx000xxxxxxx",
      "x 222  xxxxxxx",
      "xxxx     xxgxx",
      "xxxx   g    bx",
      "xxxx   x     x",
      "xxxxxxxxxxxxxx"],
      [
        {
          x: 11,
          y: 6,
          dir: 'up'
        },
        {
          x: 12,
          y: 7,
          dir: 'up'
        }
      ]
    ],
    [
      ["xxxxxxxxxxxxxx",
      "x            x",
      "xb01         x",
      "xb0gg     g  x",
      "xb023     g4bx",
      "xxxxx g   xxxx",
      "xxxxx gg  xxxx",
      "xxxxx ggg xxxx",
      "xxxxx ggggxxxx",
      "xxxxxxxxxxxxxx"],
      [
        {
          x: 12,
          y: 4,
          dir: 'down'
        }
      ]
    ],
    [
      ["xxxxxxxxxxxxxx",
      "xg0    g1gx  x",
      "x 3g    1 x  x",
      "x444    2 x  x",
      "xg g   ggg   x",
      "xxx     xxx  x",
      "xxx     xxx  x",
      "xxx     xxx  x",
      "xxx          x",
      "xxxxxxxxxxxxxx"],
      [
        {
          x: 1,
          y: 1,
          dir: 'right'
        },
        {
          x: 3,
          y: 2,
          dir: 'left'
        },
        {
          x: 1,
          y: 4,
          dir: 'up'
        },
        {
          x: 3,
          y: 4,
          dir: 'up'
        },
        {
          x: 8,
          y: 4,
          dir: 'up'
        },
        {
          x: 7,
          y: 1,
          dir: 'right'
        },
        {
          x: 9,
          y: 1,
          dir: 'left'
        }
      ]
    ],
    [
      // Level 20
      ["xxxxxxxxxxxxxx",
      "xrrrr   rggxxx",
      "xxxb    xxxxxx",
      "xxxx       xbx",
      "xx           x",
      "xx           x",
      "xx     x     x",
      "xx x         x",
      "xx        x  x",
      "xxxxxxxxxxxxxx"],
      [
        {
          x: 12,
          y: 3,
          dir: 'up'
        }
      ]
    ]
  ];

  CELL_SIZE = 48;

  moveToCell = function(dom, x, y) {
    dom.style.left = x * CELL_SIZE + 'px';
    return dom.style.top = y * CELL_SIZE + 'px';
  };

  Stage = class Stage {
    constructor(dom1, map) {
      var anchors, event, k, len, maybeSwallowEvent, ref;
      this.dom = dom1;
      this.jellies = [];
      anchors = [];
      if (map[0] instanceof Array) {
        anchors = map[1];
        map = map[0];
      }
      this.num_monochromatic_blocks = 0;
      this.num_colors = 0;
      this.loadMap(map, anchors);
      // Capture and swallow all click events during animations.
      this.busy = false;
      maybeSwallowEvent = (e) => {
        e.preventDefault();
        if (this.busy) {
          return e.stopPropagation();
        }
      };
      ref = ['contextmenu', 'click', 'touchstart', 'touchmove'];
      for (k = 0, len = ref.length; k < len; k++) {
        event = ref[k];
        this.dom.addEventListener(event, maybeSwallowEvent, true);
      }
      this.checkForMerges();
    }

    loadMap(map, anchors) {
      var cell, classname, color, colors, jelly, row, table, td, tr, x, y;
      table = document.createElement('table');
      this.dom.appendChild(table);
      colors = {};
      this.cells = (function() {
        var k, ref, results;
        results = [];
        for (y = k = 0, ref = map.length; 0 <= ref ? k < ref : k > ref; y = 0 <= ref ? ++k : --k) {
          row = map[y].split('');
          tr = document.createElement('tr');
          table.appendChild(tr);
          results.push((function() {
            var l, ref1, results1;
            results1 = [];
            for (x = l = 0, ref1 = row.length; 0 <= ref1 ? l < ref1 : l > ref1; x = 0 <= ref1 ? ++l : --l) {
              color = null;
              classname = 'transparent';
              cell = null;
              td = document.createElement('td');
              switch (row[x]) {
                case 'x':
                  classname = 'cell wall';
                  cell = new Wall(td);
                  break;
                case 'r':
                  color = 'red';
                  break;
                case 'g':
                  color = 'green';
                  break;
                case 'b':
                  color = 'blue';
                  break;
                case '0':
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                  color = 'black' + row[x];
              }
              td.className = classname;
              tr.appendChild(td);
              if (color) {
                cell = new JellyCell(color);
                jelly = new Jelly(this, cell, x, y);
                this.dom.appendChild(jelly.dom);
                this.jellies.push(jelly);
                this.num_monochromatic_blocks += 1;
                if (!(color in colors)) {
                  this.num_colors += 1;
                }
                colors[color] = 1;
              }
              results1.push(cell);
            }
            return results1;
          }).call(this));
        }
        return results;
      }).call(this);
      this.addBorders();
      this.placeAnchors(anchors);
    }

    placeAnchors(anchors) {
      var anchor, arrow, classname, colors, directions, dx, dy, jelly, k, len, me, other, property;
      directions = {
        'left': [-1, 0, 'leftarrow', 'borderRightColor'],
        'right': [1, 0, 'rightarrow', 'borderLeftColor'],
        'up': [0, -1, 'uparrow', 'borderBottomColor'],
        'down': [0, 1, 'downarrow', 'borderTopColor']
      };
      colors = {
        'red': 'hsl(0, 100%, 75%)',
        'green': 'hsl(120, 100%, 45%)',
        'blue': 'hsl(216, 100%, 70%)'
      };
      for (k = 0, len = anchors.length; k < len; k++) {
        anchor = anchors[k];
        dx = directions[anchor.dir][0];
        dy = directions[anchor.dir][1];
        classname = directions[anchor.dir][2];
        property = directions[anchor.dir][3];
        me = this.cells[anchor.y][anchor.x];
        other = this.cells[anchor.y + dy][anchor.x + dx];
        me.mergeWith(other, anchor.dir);
        // Create the overlapping anchoring triangle.
        arrow = document.createElement('div');
        arrow.style[property] = colors[me.color];
        arrow.className = classname;
        other.dom.appendChild(arrow);
      }
      return this.jellies = (function() {
        var l, len1, ref, results;
        ref = this.jellies;
        results = [];
        for (l = 0, len1 = ref.length; l < len1; l++) {
          jelly = ref[l];
          if (jelly.cells) {
            results.push(jelly);
          }
        }
        return results;
      }).call(this);
    }

    addBorders() {
      var attr, border, cell, dx, dy, edges, k, l, len, m, other, ref, ref1, ref2, ref3, x, y;
      for (y = k = 0, ref = this.cells.length; 0 <= ref ? k < ref : k > ref; y = 0 <= ref ? ++k : --k) {
        for (x = l = 0, ref1 = this.cells[0].length; 0 <= ref1 ? l < ref1 : l > ref1; x = 0 <= ref1 ? ++l : --l) {
          cell = this.cells[y][x];
          if (!(cell instanceof Wall)) {
            continue;
          }
          border = 'solid 1px #777';
          edges = [['borderBottom', 0, 1], ['borderTop', 0, -1], ['borderLeft', -1, 0], ['borderRight', 1, 0]];
          for (m = 0, len = edges.length; m < len; m++) {
            [attr, dx, dy] = edges[m];
            if (!((0 <= (ref2 = y + dy) && ref2 < this.cells.length))) {
              continue;
            }
            if (!((0 <= (ref3 = x + dx) && ref3 < this.cells[0].length))) {
              continue;
            }
            other = this.cells[y + dy][x + dx];
            if (!(other instanceof Wall)) {
              cell.dom.style[attr] = border;
            }
          }
        }
      }
    }

    waitForAnimation(cb) {
      var end, k, len, name, names;
      names = ['transitionend', 'webkitTransitionEnd'];
      end = () => {
        var k, len, name;
        for (k = 0, len = names.length; k < len; k++) {
          name = names[k];
          this.dom.removeEventListener(name, end);
        }
        // Wait one call stack before continuing.  This is necessary if there
        // are multiple pending end transition events (multiple jellies moving);
        // we want to wait for them all here and not accidentally catch them
        // in a subsequent waitForAnimation.
        return setTimeout(cb, 0);
      };
      for (k = 0, len = names.length; k < len; k++) {
        name = names[k];
        this.dom.addEventListener(name, end);
      }
    }

    trySlide(jelly, dir) {
      var jellies;
      jellies = [jelly];
      if (this.checkFilled(jellies, dir, 0)) {
        return;
      }
      this.busy = true;
      this.move(jellies, dir, 0);
      return this.waitForAnimation(() => {
        return this.checkFall(() => {
          this.checkForMerges();
          return this.busy = false;
        });
      });
    }

    move(jellies, dx, dy) {
      var cell, jelly, k, l, len, len1, len2, len3, len4, m, n, o, ref, ref1, x, y;
      for (k = 0, len = jellies.length; k < len; k++) {
        jelly = jellies[k];
        ref = jelly.cellCoords();
        for (l = 0, len1 = ref.length; l < len1; l++) {
          [x, y, cell] = ref[l];
          this.cells[y][x] = null;
        }
      }
      for (m = 0, len2 = jellies.length; m < len2; m++) {
        jelly = jellies[m];
        jelly.updatePosition(jelly.x + dx, jelly.y + dy);
      }
      for (n = 0, len3 = jellies.length; n < len3; n++) {
        jelly = jellies[n];
        ref1 = jelly.cellCoords();
        for (o = 0, len4 = ref1.length; o < len4; o++) {
          [x, y, cell] = ref1[o];
          this.cells[y][x] = cell;
        }
      }
    }

    checkFilled(jellies, dx, dy) {
      var cell, done, jelly, k, l, len, len1, next, ref, ref1, x, y;
      done = false;
      while (!done) {
        done = true;
        for (k = 0, len = jellies.length; k < len; k++) {
          jelly = jellies[k];
          if (jelly.immovable) {
            return true;
          }
          ref = jelly.cellCoords();
          for (l = 0, len1 = ref.length; l < len1; l++) {
            [x, y, cell] = ref[l];
            next = this.cells[y + dy][x + dx];
            if (!next) { // empty space
              continue;
            }
            if (!next.jelly) { // wall
              return true;
            }
            if (ref1 = next.jelly, indexOf.call(jellies, ref1) >= 0) {
              continue;
            }
            jellies.push(next.jelly);
            done = false;
            break;
          }
        }
      }
      return false;
    }

    checkFall(cb) {
      var jelly, jellyset, k, len, moved, ref, try_again;
      moved = false;
      try_again = true;
      while (try_again) {
        try_again = false;
        ref = this.jellies;
        for (k = 0, len = ref.length; k < len; k++) {
          jelly = ref[k];
          jellyset = [jelly];
          if (!this.checkFilled(jellyset, 0, 1)) {
            this.move(jellyset, 0, 1);
            try_again = true;
            moved = true;
          }
        }
      }
      if (moved) {
        this.waitForAnimation(cb);
      } else {
        cb();
      }
    }

    checkForMerges() {
      var merged;
      merged = false;
      while (this.doOneMerge()) {
        merged = true;
      }
      if (merged) {
        this.checkForCompletion();
      }
    }

    checkForCompletion() {
      if (this.num_monochromatic_blocks <= this.num_colors) {
        alert("Congratulations! Level completed.");
      }
    }

    doOneMerge() {
      var cell, dir, dx, dy, jelly, k, l, len, len1, len2, m, other, ref, ref1, ref2, x, y;
      ref = this.jellies;
      for (k = 0, len = ref.length; k < len; k++) {
        jelly = ref[k];
        ref1 = jelly.cellCoords();
        for (l = 0, len1 = ref1.length; l < len1; l++) {
          [x, y, cell] = ref1[l];
          ref2 = [[1, 0, 'right'], [0, 1, 'down']];
          // Only look right and down; left and up are handled by that side
          // itself looking right and down.
          for (m = 0, len2 = ref2.length; m < len2; m++) {
            [dx, dy, dir] = ref2[m];
            other = this.cells[y + dy][x + dx];
            if (!(other && other instanceof JellyCell)) {
              continue;
            }
            if (cell['merged' + dir]) {
              continue;
            }
            if (other.color !== cell.color) {
              continue;
            }
            if (jelly !== other.jelly) {
              this.jellies = this.jellies.filter(function(j) {
                return j !== other.jelly;
              });
            }
            if (cell.color_master !== other.color_master) {
              this.num_monochromatic_blocks -= 1;
            }
            cell.mergeWith(other, dir);
            cell['merged' + dir] = true;
            return true;
          }
        }
      }
      return false;
    }

  };

  Wall = class Wall {
    constructor(dom1) {
      this.dom = dom1;
    }

  };

  JellyCell = class JellyCell {
    constructor(color1) {
      this.color = color1;
      this.dom = document.createElement('div');
      this.dom.className = 'cell jelly ' + this.color;
      this.x = 0;
      this.y = 0;
      this.color_master = this;
      this.color_mates = [this];
    }

    mergeWith(other, dir) {
      var borders, cell, k, len, other_master, ref;
      borders = {
        'left': ['borderLeft', 'borderRight'],
        'right': ['borderRight', 'borderLeft'],
        'up': ['borderTop', 'borderBottom'],
        'down': ['borderBottom', 'borderTop']
      };
      // Remove internal borders, whether merging with other jelly or wall.
      this.dom.style[borders[dir][0]] = 'none';
      other.dom.style[borders[dir][1]] = 'none';
      if (other instanceof Wall) {
        // If merging with wall, jelly becomes immovable.
        this.jelly.immovable = true;
      }
      // If merging with jelly, unify the jellies and color mates' lists.
      if (other instanceof JellyCell && this.color === other.color && this.color_master !== other.color_master) {
        other_master = other.color_master;
        ref = other_master.color_mates;
        for (k = 0, len = ref.length; k < len; k++) {
          cell = ref[k];
          cell.color_master = this.color_master;
        }
        this.color_master.color_mates = this.color_master.color_mates.concat(other_master.color_mates);
      }
      if (other instanceof JellyCell && this.jelly !== other.jelly) {
        return this.jelly.merge(other.jelly);
      }
    }

  };

  Jelly = class Jelly {
    constructor(stage, cell, x1, y1) {
      this.x = x1;
      this.y = y1;
      this.dom = document.createElement('div');
      this.updatePosition(this.x, this.y);
      this.dom.className = 'cell jellybox';
      cell.jelly = this;
      this.cells = [cell];
      this.dom.appendChild(cell.dom);
      this.dom.addEventListener('contextmenu', (e) => {
        return stage.trySlide(this, 1);
      });
      this.dom.addEventListener('click', (e) => {
        return stage.trySlide(this, -1);
      });
      this.dom.addEventListener('touchstart', (e) => {
        return this.start = e.touches[0].pageX;
      });
      this.dom.addEventListener('touchmove', (e) => {
        var dx;
        dx = e.touches[0].pageX - this.start;
        if (Math.abs(dx) > 10) {
          dx = Math.max(Math.min(dx, 1), -1);
          return stage.trySlide(this, dx);
        }
      });
      this.immovable = false;
    }

    cellCoords() {
      var cell, k, len, ref, results;
      ref = this.cells;
      results = [];
      for (k = 0, len = ref.length; k < len; k++) {
        cell = ref[k];
        results.push([this.x + cell.x, this.y + cell.y, cell]);
      }
      return results;
    }

    updatePosition(x1, y1) {
      this.x = x1;
      this.y = y1;
      return moveToCell(this.dom, this.x, this.y);
    }

    merge(other) {
      var cell, dx, dy, k, len, ref;
      // Reposition other's cells as children of this jelly.
      dx = other.x - this.x;
      dy = other.y - this.y;
      ref = other.cells;
      for (k = 0, len = ref.length; k < len; k++) {
        cell = ref[k];
        this.cells.push(cell);
        cell.x += dx;
        cell.y += dy;
        cell.jelly = this;
        moveToCell(cell.dom, cell.x, cell.y);
        this.dom.appendChild(cell.dom);
      }
      if (other.immovable) {
        this.immovable = true;
      }
      // Delete references from/to other.
      other.cells = null;
      other.dom.parentNode.removeChild(other.dom);
    }

  };

  level = parseInt(location.search.substr(1), 10) || 1;

  stage = new Stage(document.getElementById('map'), levels[level - 1]);

  window.stage = stage;

  levelPicker = document.getElementById('level');

  for (i = k = 1, ref = levels.length; 1 <= ref ? k <= ref : k >= ref; i = 1 <= ref ? ++k : --k) {
    option = document.createElement('option');
    option.value = i;
    option.appendChild(document.createTextNode(`Level ${i}`));
    levelPicker.appendChild(option);
  }

  levelPicker.value = level;

  levelPicker.addEventListener('change', function() {
    return location.search = '?' + levelPicker.value;
  });

  document.getElementById('reset').addEventListener('click', function() {
    stage.dom.innerHTML = '';
    return stage = new Stage(stage.dom, levels[level - 1]);
  });

}).call(this);
